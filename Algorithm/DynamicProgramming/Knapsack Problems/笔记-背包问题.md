# 背包动态规划（背包问题）
- 01 背包
- 完全背包
- 多重背包（二进制优化，优先队列优化）
- 分组背包
- 附件背包
- 混合背包

衍生：背包方案数 刚好装满的最大价值

---

物品数量：n
背包体积：w
物品体积：v[i]
物品价值：c[i]

一、01 背包
特点：物品只有一件（拿与不拿两种选择）

二维写法
1. 确定状态：`dp[i][j]`表示前i件商品在背包体积为j的时候的最大价值
2. 状态转移方程式：
    1. 装得下：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]]+c[i])`（当可以装的前提下！v[i] <= j）
    2. 装不下：`dp[i][j] = dp[i-1][j]`
3. 初始化：当什么物品都不选的时候，价值都为0 `dp[0][j] = 0`
4. 返回结果：`dp[n][w]`

一维写法
1. 确定状态：`dp[j]`表示前i件商品在背包体积为j的时候的最大价值
2. 状态转移方程式：`dp[j] = max(dp[j], dp[j-v[i]]+c[i])`
    1. 装得下：`dp[i][j] = max(dp[j], dp[j-v[i]]+c[i])`（当可以装的前提下！`v[i] <= j`）
    2. 装不下：不动
3. 初始化：当什么物品都不选的时候，价值都为0 `dp[j] = 0`
4. 返回结果：`dp[w]`
重点：1维的背包容量需要倒着遍历。

二、完全背包
与01背包的区别：物品可以有多件
- 二维写法：`dp[i][j] = max(dp[i-1][j], max(dp[i-1][j-k*w[i]]+k*c[i]));`  前提是要装得下。
- 二维升级写法：`dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]]+c[i]);`
- 一维写法： `dp[j] = max(dp[j], dp[j-w[i]]+c[i]);`  要正着循环

PaLM

三、多重背包
- 特点：物品的数量是有限的

二维写法：`dp[i][j] = max(dp[i][j], dp[i-1][j-k*v[i]]+k*c[i]);`  // 比较每个方案的最优解
一维写法：`dp[j] = max(dp[j], dp[j-k*v[i]]+k*c[i]);`
注意：循环顺序 i, j, k 不能改变。

