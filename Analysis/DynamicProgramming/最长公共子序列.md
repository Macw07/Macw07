# T242636 最长公共子序列

### 题目描述

输入2个字符串，字符串的字符最多n个（$ n \leq 100 $），求它们的最长公共子序列。

### 输入格式

输入2行，每行一个字符串

### 输出格式

个数，即最长公共子序列的长度。

### 样例输入 #1

```
algorithm
alabritac
```

### 样例输出 #1

```
5
```

# 题解

### 概述：

这是一道动态规划的题目，一般情况下，动态规划会要求选手寻找最值。

第一步：创建一个二位的表格（dp数组）确定dp数组的含义：`dp[i][j]` 的含义是：对于 `s1[1..i]`和 `s2[1..j]`，它们的 LCS 长度是 `dp[i][j]`。

第二步：初始化dp数组，将第0排和第0列都初始化为0（全局变量默认初始化），表示的是没有公共子序列，长度为0。

第三步：确定递推公式，分为两种情况讨论 - 字符串的`[i]`是否等于字符串的`[j]`。

- `arr[i] = arr[j]，dp[i][j] = dp[i-1][j-1] + 1;`
- `arr[i] != arr[j]，dp[i][j] = max(dp[i-1][j], dp[i][j-1]);`

最后输出 dp\[n][n];

### 最终AC代码

``` c++
#include <iostream>
#include <algorithm>
using namespace std;

int dp[105][105];  // 创建dp数组。

int main(){
    string a, b;
    cin >> a >> b;
    int la = a.size(), lb = b.size();  // 为了方便，先获取两个字符串的长度。
    for (int i=1; i<=la; i++){
        for (int j=1; j<=lb; j++){
            if (a[i-1] == b[j-1]) dp[i][j] = dp[i-1][j-1]+1;  // 情况1，如果两个字母相同。
            else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);  // 情况2，两个字母不相同。
        }
    }
    cout << dp[la][lb] << endl;  // 输出结果。
}
```

