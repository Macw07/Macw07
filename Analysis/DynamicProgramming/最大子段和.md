# P1115 最大子段和

### 题目描述

给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。

### 输入格式

第一行是一个整数，表示序列的长度 $n$。

第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。

### 输出格式

输出一行一个整数表示答案。

### 样例输入 #1

```
7
2 -4 3 -1 2 -4 3
```

### 样例输出 #1

```
4
```

### 提示

#### 样例 1 解释

选取 $[3, 5]$ 子段 $\{3, -1, 2\}$，其和为 $4$。

#### 数据规模与约定

- 对于 $40\%$ 的数据，保证 $n \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。

# 题解

### 题目分析：

根据题意，我们需要在一个数组中找到一个连续子数组，使得这段子数组的和最大。
根据这道题，我们优先考虑使用贪心算法来求解。

### 求解思路：

中心思路：设定一个变量进行累加，只要不是负数就不舍弃。因为如果碰到负数以后就会让整一个数组的值呈一个负增长状态。
举个例子：数组 [1, 2, -1, 4, 5]中，最大的子段和为 $1+2-1+4+5 = 11$ 。虽然遇到了负数，但是不会让数组出现非常大的损失。
与此同时，我们还需要设定一个变量 $ans$ 每次更新完数组以后都记录最大值，这样能保证答案一定是每一个可行结果中的最大值。

### **记录最大值：**

``` c++
int ans = 0;
// 在每次循环的时候都记录
ans = max(ans, temp);  
```

### 最终AC代码

``` c++
#include <iostream>
#include <algorithm>
using namespace std;
// 尽量不要使用万能头，可能会出现问题。
int arr[200005];  // 看清楚数据范围，把数组设定为全局变量。
int main(){
    int n;
    cin >> n;
    for (int i=0; i<n; i++){
        cin >> arr[i];  // 循环读入数组里面的值。
    }
    // 核心代码
    int ans = -0x7f7f7f;  // 存储最终答案，设定为负数为了防止整个数组都是负数。。
    int temp = 0;  // 临时变量存储每一个状态。
    for (int i=0; i<n; i++){
        temp += arr[i];
        ans = max(ans, temp);  // 一定要放在前面先判断。
        if (temp <= 0){
            temp = 0;  // 出现负增长状态，就要立刻舍弃。不要temp=arr[i]，因为负数不应该被留下。
        }
    }
    cout << ans << endl;
    return 0;
}
```



