# 全排列问题

> 给定一个数字n，求集合1到n的全排列

**前言**： 全排列问题是一种典型的排列组合问题，全排列的实现方法是通过深度优先搜素DFS来实现的。

### 难点汇总

**如何保证数字不重复？**

``` c++
#include <iostream>
// 我们可以通过建立一个数组来记录这个数字是否被访问过
bool vis[100];  // vis[i]代表的就是第i个元素是否被访问过
```

**递归程序如何设计？**

递归三部曲

1. 确定本次递归的结束条件 -> 当一轮排列组合已经完成了以后就结束当前递归，并输出结果。
2. 递归的返回值 -> 这次是需要求排列组合，不需要返回任何东西。因此函数的类型为`void`。
3. 本轮递归要干什么 -> 本轮的递归就是不断尝试未访问的节点并加入到数组。不断访问可以通过`for`循环来实现。

深度优先搜索的模板

``` c++
void dfs(参数1, 参数2){
    if {递归的结束条件}{
        {答案增加｜输出答案}
        return;
    }
    {遍历这一层所有的可能性}
    for (int i=1; i<=n; i++){
        {状态锁定}
        {需要干的事情}
        {状态解除}
    }
    return;
}
```

**关于回溯算法的理解**

这里的递归的本质就是不断尝试，暴力尝试所有可以的数字并加入到数组中。将`vis[i]`设定为1相当于锁定了这个格子，在之后的“本轮”遍历中就不会在用它了。相反，解除状态锁定更是像一种后悔药，当一种情况已经确定下来了，还需要再找到另一个可行的情况下，回溯算法就可以回归到这个数字没有被选中的情况下，在之后的遍历中再次被其他的位置给选中。虽然一开始回溯算法非常不好理解，但是等到后来题目做的越来越多的时候自己就会有一个清晰的概念了。

这里有一个比较官方的解释，也比较容易理解：

> 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。
>
> 但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

### 递归程序设计

``` c++
void dfs(int k){  // 函数不需要返回值，k代表的是函数当前递归的层级
    if (k == n){  // 结束条件，当排列结果数组的长度等于数组的原长度
        {打印结果}
        return;
    }
    for (int i=1; i<=n; i++){  // 不断尝试1-n的每一个数字
        if (vis[i] == 0){  // 如果没有被用过
            vis[i] = 1;  // 将数字标记为占用
            {将答案加入数组}
            dfs(i+1);  // 递归下一层
            vis[i] = 0;  // 将数字取消占用
        }
    }
    return;
}
```

### 最终程序设计 + 注释

``` c++
#include <iostream>
#include <vector>
using namespace std;

int n;
vector<int> path;  // 保存的是每一次结果
vector<vector<int> > result;  // 保存的是所有的结果
int vis[100];  // 表示数字是否被占用

void dfs(int k){  // 函数不需要返回值，k代表的是函数当前递归的层级
    if (k == n){  // 结束条件，当排列结果数组的长度等于数组的原长度
        result.push_back(path);
        return;
    }
    for (int i=1; i<=n; i++){  // 不断尝试1-n的每一个数字
        if (vis[i] == 0){  // 如果没有被用过
            vis[i] = 1;  // 将数字标记为占用
            path.push_back(i);  // 添加答案
            dfs(i+1);  // 递归下一层
            vis[i] = 0;  // 将数字取消占用
            path.pop_back();   // 回溯
        }
    }
    return;
}

int main(){
    cin >> n;
    dfs(1);
    for (int i=0; i<result.size(); i++){
        for (int j=0; j<n; j++){
            cout << result[i][j] << " ";  // 输出结果
        }
        cout << endl;
    }
    return 0;
}
```

