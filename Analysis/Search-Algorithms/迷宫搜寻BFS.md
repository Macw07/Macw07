# 迷宫搜寻 - 广度优先搜索算法的求解思路

> 广度优先算法一般用于求解最短的路径，而不是求解左右可行的路径。
> 相比之下，求解左右可行的路径使用深度优先搜索算法（DFS）会更加的方便。

### 什么是广度优先搜索算法？

广度优先搜索算法就是逐一的从一个位置向自己的四周进行拓展。
广度优先搜索算法一般情况下通过队列`queue`来实现。

### 程序实现过程 + 注释

``` c++
#include <iostream>
#include <algorithm>
#include <queue>  // 广度优先搜索需要使用STL库中的队列来实现，因此需要导入
using namespace std;

int n, m;  // 定义n和m,n和m既可以表示图的大小,也可以表示成图的终点坐标
char map[50][50];  // 创建一个char类型的二维地图数组,负责记录图中的元素
int dx[4] = {0, 1, 0, -1};  // x坐标的偏移
int dy[4] = {1, 0, -1, 0};  // y坐标的偏移
int vis[50][50];  // 用于记录坐标是否被访问过了

// 创建一个结构体，结构体的作用就是将数据打包存入队列中
struct node{
    int x, y, steps;  // x, y表示的是位置的坐标，steps是指拓展到该位置时候的步数
};

queue<node> q;  // 创建队列，数据类型为node

void bfs(){  // 广度优先搜索函数并不是递归函数，也不需要特定的参数
    // 初始化队列，将初始位置加入到队列
    q.push((node){1, 1, 0});
    vis[1][1] = 1;  // 切记，一定要将初始位置设定为已访问才可以
    while(!q.empty()){  // 在进行队列操做的时候，需要保证队列不可以为空，否则就会出现错误
        node t = q.front();  // 获取队首元素
        // 判断是否走到了终点
        if (t.x == n && t.y == m){cout << t.steps; return;}  // 结束即可，后面的操作无意义了
        for (int i=0; i<4; i++){  // 向四个方向进行遍历
            int cx = t.x + dx[i];
            int cy = t.y + dy[i];
            // 判断是否出界
            if (cx > n || cy > m || cx < 1 || cy < 1) continue;
            // 如果要访问的元素没有被访问过且不是障碍物时
            if (vis[cx][cy] == 0 && map[cx][cy] != '#'){
                vis[cx][cy] = 1;  // 将元素设定为已访问
                q.push((node){cx, cy, t.steps+1});  // 加入到队列，并且让步数增加1
            }
        }
        q.pop();  // 操作完队首元素后一定要及时删除，否则就会陷入死循环
    }  
}

int main(){
    cin >> n >> m;
    for (int i=1; i<=n; i++)
        for (int j=1; j<=m; j++)
            cin >> map[i][j];  // 循环读入数组的每一个元素
	bfs();
    return 0;
}
```

> 相比之下，广度优先搜索算法的代码比深度优先搜索的代码要长，但总体上差不多。
> 根据具体的使用场景选择合适的算法。
